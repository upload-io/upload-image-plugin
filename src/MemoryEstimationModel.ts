import { MemoryEstimationModelParameters } from "upload-image-plugin/types/MemoryEstimationModelParameters";
import { OutputImageFormat } from "upload-image-plugin/types/OutputImageFormat";

/**
 * See README.md.
 */
export class MemoryEstimationModel {
  /**
   * Generated by MemoryEstimationModelTrainer.
   */
  private static readonly modelParameters = {
    jpg: { spaceCoefficient: 0.0187, spaceConstant: 9316, shareCoefficient: 0.135, shareConstant: 0 },
    jp2: { spaceCoefficient: 0.0325, spaceConstant: 10579, shareCoefficient: 1.015, shareConstant: 0 },
    png: { spaceCoefficient: 0.0231, spaceConstant: 18000, shareCoefficient: 0.3592, shareConstant: 1492105 },
    gif: { spaceCoefficient: 0.0274, spaceConstant: 81000, shareCoefficient: 0, shareConstant: 921053 },
    webp: { spaceCoefficient: 0.0187, spaceConstant: 9316, shareCoefficient: 0.135, shareConstant: 0 }
  };

  private static readonly modelParametersPartial: Partial<Record<OutputImageFormat, MemoryEstimationModelParameters>> =
    MemoryEstimationModel.modelParameters;

  /**
   * Use one of the more expensive formats, so we overestimate.
   */
  private static readonly defaultModelParameters = MemoryEstimationModel.modelParameters.jp2;

  /**
   * Function must never underestimate, as this will case OOMs. Overestimations are undesirable in the sense that they
   * result in wasted resources, and extra cost (GB-seconds) for the user.
   */
  static getEstimateInKBForFormat(
    inputPixelCount: number,
    outputPixelCount: number,
    inputFormat: OutputImageFormat,
    outputFormat: OutputImageFormat
  ): number {
    return MemoryEstimationModel.getEstimateInKB(
      inputPixelCount,
      outputPixelCount,
      MemoryEstimationModel.getModelParamsForFormat(inputFormat),
      MemoryEstimationModel.getModelParamsForFormat(outputFormat)
    );
  }

  static getEstimateInKB(
    inputPixelCount: number,
    outputPixelCount: number,
    inputParameters: MemoryEstimationModelParameters,
    outputParameters: MemoryEstimationModelParameters
  ): number {
    const spaceRequiredForPixelsKB = (pixelCount: number, p: MemoryEstimationModelParameters): number =>
      p.spaceCoefficient * pixelCount + p.spaceConstant;

    const spaceForInput = spaceRequiredForPixelsKB(inputPixelCount, inputParameters);
    const spaceForOutput = spaceRequiredForPixelsKB(outputPixelCount, outputParameters);

    let largeImage: number;
    let largeImageParams: MemoryEstimationModelParameters;
    let smallImage: number;
    let smallImageParams: MemoryEstimationModelParameters;
    let spaceRequiredForLargeImageKB: number;

    if (spaceForInput > spaceForOutput) {
      spaceRequiredForLargeImageKB = spaceForInput;
      largeImage = inputPixelCount;
      largeImageParams = inputParameters;

      smallImage = outputPixelCount;
      smallImageParams = outputParameters;
    } else {
      spaceRequiredForLargeImageKB = spaceForOutput;
      largeImage = outputPixelCount;
      largeImageParams = outputParameters;

      smallImage = inputPixelCount;
      smallImageParams = inputParameters;
    }

    const pixelsReusedFromLargeImage = largeImageParams.shareCoefficient * largeImage + largeImageParams.shareConstant;
    const spaceRequiredForSmallImageKB = Math.max(
      0,
      spaceRequiredForPixelsKB(smallImage - pixelsReusedFromLargeImage, smallImageParams)
    );
    return Math.ceil(spaceRequiredForLargeImageKB + spaceRequiredForSmallImageKB);
  }

  private static getModelParamsForFormat(format: OutputImageFormat): MemoryEstimationModelParameters {
    return MemoryEstimationModel.modelParametersPartial[format] ?? MemoryEstimationModel.defaultModelParameters;
  }
}
