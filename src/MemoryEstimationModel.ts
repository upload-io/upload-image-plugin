import { MemoryEstimationModelParameters } from "upload-image-plugin/types/MemoryEstimationModelParameters";
import { OutputImageFormat } from "upload-image-plugin/types/OutputImageFormat";

/**
 * See README.md.
 */
export class MemoryEstimationModel {
  /**
   * Generated by MemoryEstimationModelTrainer.
   */
  private static readonly modelParameters = {
    jpg: { spaceCoefficient: 0.0187, spaceConstant: 9526, shareCoefficient: 0.135, shareConstant: 0 },
    jp2: { spaceCoefficient: 0.0325, spaceConstant: 10895, shareCoefficient: 0.9237, shareConstant: 0 },
    png: { spaceCoefficient: 0.0231, spaceConstant: 18000, shareCoefficient: 0.3592, shareConstant: 1476316 },
    gif: { spaceCoefficient: 0.0274, spaceConstant: 81000, shareCoefficient: 0, shareConstant: 921053 },
    webp: { spaceCoefficient: 0.0187, spaceConstant: 9526, shareCoefficient: 0.135, shareConstant: 0 }
  };

  private static readonly modelParametersPartial: Partial<Record<OutputImageFormat, MemoryEstimationModelParameters>> =
    MemoryEstimationModel.modelParameters;

  /**
   * Use one of the more expensive formats, so we overestimate.
   */
  private static readonly defaultModelParameters = MemoryEstimationModel.modelParameters.jp2;

  /**
   * Function must never underestimate, as this will case OOMs. Overestimations are undesirable in the sense that they
   * result in wasted resources, and extra cost (GB-seconds) for the user.
   */
  static getEstimateInKBForFormat(
    inputPixelCount: number,
    outputPixelCount: number,
    inputFormat: OutputImageFormat,
    outputFormat: OutputImageFormat
  ): number {
    return MemoryEstimationModel.getEstimateInKB(
      inputPixelCount,
      outputPixelCount,
      MemoryEstimationModel.getModelParamsForFormat(inputFormat),
      MemoryEstimationModel.getModelParamsForFormat(outputFormat)
    );
  }

  static getEstimateInKB(
    inputPixels: number,
    outputPixels: number,
    inputParams: MemoryEstimationModelParameters,
    outputParams: MemoryEstimationModelParameters
  ): number {
    const spaceRequiredKB = (pixelCount: number, p: MemoryEstimationModelParameters): number =>
      p.spaceCoefficient * pixelCount + p.spaceConstant;

    const inputSpace = spaceRequiredKB(inputPixels, inputParams);
    const outputSpace = spaceRequiredKB(outputPixels, outputParams);

    let largePixels: number;
    let largeParams: MemoryEstimationModelParameters;
    let smallPixels: number;
    let smallParams: MemoryEstimationModelParameters;
    let largeSpaceKB: number;

    if (inputSpace > outputSpace) {
      largeSpaceKB = inputSpace;
      largePixels = inputPixels;
      largeParams = inputParams;

      smallPixels = outputPixels;
      smallParams = outputParams;
    } else {
      largeSpaceKB = outputSpace;
      largePixels = outputPixels;
      largeParams = outputParams;

      smallPixels = inputPixels;
      smallParams = inputParams;
    }

    const pixelsReusedFromLargeImage = largeParams.shareCoefficient * largePixels + largeParams.shareConstant;
    const smallSpaceKB = Math.max(0, spaceRequiredKB(smallPixels - pixelsReusedFromLargeImage, smallParams));
    return Math.ceil(largeSpaceKB + smallSpaceKB);
  }

  private static getModelParamsForFormat(format: OutputImageFormat): MemoryEstimationModelParameters {
    return MemoryEstimationModel.modelParametersPartial[format] ?? MemoryEstimationModel.defaultModelParameters;
  }
}
